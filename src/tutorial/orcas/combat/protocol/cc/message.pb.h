// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "warrior.pb.h"
// @@protoc_insertion_point(includes)

namespace tutorial {
namespace orcas {
namespace combat {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class CombatRoleData;
class CombatCampData;
class CombatInitialData;
class MessageCombatDeployRequest;
class MessageCombatDeployResponse;
class MessageCombatConnectArgentRequest;
class MessageCombatConnectArgentResponse;
class MessageCombatArgentRequest;
class MessageCombatArgentSync;

enum MessageCombatConnectArgentResponse_ErrorCode {
  MessageCombatConnectArgentResponse_ErrorCode_ERROR_CODE_COMPLETE = 0,
  MessageCombatConnectArgentResponse_ErrorCode_ERROR_CODE_FAILURE = -1
};
bool MessageCombatConnectArgentResponse_ErrorCode_IsValid(int value);
const MessageCombatConnectArgentResponse_ErrorCode MessageCombatConnectArgentResponse_ErrorCode_ErrorCode_MIN = MessageCombatConnectArgentResponse_ErrorCode_ERROR_CODE_FAILURE;
const MessageCombatConnectArgentResponse_ErrorCode MessageCombatConnectArgentResponse_ErrorCode_ErrorCode_MAX = MessageCombatConnectArgentResponse_ErrorCode_ERROR_CODE_COMPLETE;
const int MessageCombatConnectArgentResponse_ErrorCode_ErrorCode_ARRAYSIZE = MessageCombatConnectArgentResponse_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageCombatConnectArgentResponse_ErrorCode_descriptor();
inline const ::std::string& MessageCombatConnectArgentResponse_ErrorCode_Name(MessageCombatConnectArgentResponse_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageCombatConnectArgentResponse_ErrorCode_descriptor(), value);
}
inline bool MessageCombatConnectArgentResponse_ErrorCode_Parse(
    const ::std::string& name, MessageCombatConnectArgentResponse_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageCombatConnectArgentResponse_ErrorCode>(
    MessageCombatConnectArgentResponse_ErrorCode_descriptor(), name, value);
}
enum CombatType {
  COMBAT_TYPE_MIN = 0,
  COMBAT_TYPE_PVE = 1,
  COMBAT_TYPE_PVP = 2,
  COMBAT_TYPE_GVG = 3,
  COMBAT_TYPE_MAX = 4
};
bool CombatType_IsValid(int value);
const CombatType CombatType_MIN = COMBAT_TYPE_MIN;
const CombatType CombatType_MAX = COMBAT_TYPE_MAX;
const int CombatType_ARRAYSIZE = CombatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CombatType_descriptor();
inline const ::std::string& CombatType_Name(CombatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CombatType_descriptor(), value);
}
inline bool CombatType_Parse(
    const ::std::string& name, CombatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CombatType>(
    CombatType_descriptor(), name, value);
}
enum CombatDeployResultType {
  COMBAT_DEPLOY_RESULT_TYPE_MIN = 0,
  COMBAT_DEPLOY_RESULT_TYPE_COMPLETE = 1,
  COMBAT_DEPLOY_RESULT_TYPE_FAILURE = 2,
  COMBAT_DEPLOY_RESULT_TYPE_MAX = 3
};
bool CombatDeployResultType_IsValid(int value);
const CombatDeployResultType CombatDeployResultType_MIN = COMBAT_DEPLOY_RESULT_TYPE_MIN;
const CombatDeployResultType CombatDeployResultType_MAX = COMBAT_DEPLOY_RESULT_TYPE_MAX;
const int CombatDeployResultType_ARRAYSIZE = CombatDeployResultType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CombatDeployResultType_descriptor();
inline const ::std::string& CombatDeployResultType_Name(CombatDeployResultType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CombatDeployResultType_descriptor(), value);
}
inline bool CombatDeployResultType_Parse(
    const ::std::string& name, CombatDeployResultType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CombatDeployResultType>(
    CombatDeployResultType_descriptor(), name, value);
}
// ===================================================================

class CombatRoleData : public ::google::protobuf::Message {
 public:
  CombatRoleData();
  virtual ~CombatRoleData();

  CombatRoleData(const CombatRoleData& from);

  inline CombatRoleData& operator=(const CombatRoleData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatRoleData& default_instance();

  void Swap(CombatRoleData* other);

  // implements Message ----------------------------------------------

  CombatRoleData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CombatRoleData& from);
  void MergeFrom(const CombatRoleData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 argent_id = 1;
  inline bool has_argent_id() const;
  inline void clear_argent_id();
  static const int kArgentIdFieldNumber = 1;
  inline ::google::protobuf::uint64 argent_id() const;
  inline void set_argent_id(::google::protobuf::uint64 value);

  // required string ai = 2;
  inline bool has_ai() const;
  inline void clear_ai();
  static const int kAiFieldNumber = 2;
  inline const ::std::string& ai() const;
  inline void set_ai(const ::std::string& value);
  inline void set_ai(const char* value);
  inline void set_ai(const char* value, size_t size);
  inline ::std::string* mutable_ai();
  inline ::std::string* release_ai();
  inline void set_allocated_ai(::std::string* ai);

  // repeated .protocol.WarriorDescription warrior = 3;
  inline int warrior_size() const;
  inline void clear_warrior();
  static const int kWarriorFieldNumber = 3;
  inline const ::protocol::WarriorDescription& warrior(int index) const;
  inline ::protocol::WarriorDescription* mutable_warrior(int index);
  inline ::protocol::WarriorDescription* add_warrior();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::WarriorDescription >&
      warrior() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::WarriorDescription >*
      mutable_warrior();

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.CombatRoleData)
 private:
  inline void set_has_argent_id();
  inline void clear_has_argent_id();
  inline void set_has_ai();
  inline void clear_has_ai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 argent_id_;
  ::std::string* ai_;
  ::google::protobuf::RepeatedPtrField< ::protocol::WarriorDescription > warrior_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static CombatRoleData* default_instance_;
};
// -------------------------------------------------------------------

class CombatCampData : public ::google::protobuf::Message {
 public:
  CombatCampData();
  virtual ~CombatCampData();

  CombatCampData(const CombatCampData& from);

  inline CombatCampData& operator=(const CombatCampData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatCampData& default_instance();

  void Swap(CombatCampData* other);

  // implements Message ----------------------------------------------

  CombatCampData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CombatCampData& from);
  void MergeFrom(const CombatCampData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .tutorial.orcas.combat.protocol.CombatRoleData role = 2;
  inline int role_size() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 2;
  inline const ::tutorial::orcas::combat::protocol::CombatRoleData& role(int index) const;
  inline ::tutorial::orcas::combat::protocol::CombatRoleData* mutable_role(int index);
  inline ::tutorial::orcas::combat::protocol::CombatRoleData* add_role();
  inline const ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatRoleData >&
      role() const;
  inline ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatRoleData >*
      mutable_role();

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.CombatCampData)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatRoleData > role_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static CombatCampData* default_instance_;
};
// -------------------------------------------------------------------

class CombatInitialData : public ::google::protobuf::Message {
 public:
  CombatInitialData();
  virtual ~CombatInitialData();

  CombatInitialData(const CombatInitialData& from);

  inline CombatInitialData& operator=(const CombatInitialData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatInitialData& default_instance();

  void Swap(CombatInitialData* other);

  // implements Message ----------------------------------------------

  CombatInitialData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CombatInitialData& from);
  void MergeFrom(const CombatInitialData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 map_id() const;
  inline void set_map_id(::google::protobuf::int32 value);

  // required int32 combat_type = 2;
  inline bool has_combat_type() const;
  inline void clear_combat_type();
  static const int kCombatTypeFieldNumber = 2;
  inline ::google::protobuf::int32 combat_type() const;
  inline void set_combat_type(::google::protobuf::int32 value);

  // repeated .tutorial.orcas.combat.protocol.CombatCampData camp = 3;
  inline int camp_size() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 3;
  inline const ::tutorial::orcas::combat::protocol::CombatCampData& camp(int index) const;
  inline ::tutorial::orcas::combat::protocol::CombatCampData* mutable_camp(int index);
  inline ::tutorial::orcas::combat::protocol::CombatCampData* add_camp();
  inline const ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatCampData >&
      camp() const;
  inline ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatCampData >*
      mutable_camp();

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.CombatInitialData)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_combat_type();
  inline void clear_has_combat_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 map_id_;
  ::google::protobuf::int32 combat_type_;
  ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatCampData > camp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static CombatInitialData* default_instance_;
};
// -------------------------------------------------------------------

class MessageCombatDeployRequest : public ::google::protobuf::Message {
 public:
  MessageCombatDeployRequest();
  virtual ~MessageCombatDeployRequest();

  MessageCombatDeployRequest(const MessageCombatDeployRequest& from);

  inline MessageCombatDeployRequest& operator=(const MessageCombatDeployRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCombatDeployRequest& default_instance();

  void Swap(MessageCombatDeployRequest* other);

  // implements Message ----------------------------------------------

  MessageCombatDeployRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageCombatDeployRequest& from);
  void MergeFrom(const MessageCombatDeployRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 host_id = 1;
  inline bool has_host_id() const;
  inline void clear_host_id();
  static const int kHostIdFieldNumber = 1;
  inline ::google::protobuf::int32 host_id() const;
  inline void set_host_id(::google::protobuf::int32 value);

  // required .tutorial.orcas.combat.protocol.CombatInitialData combat_initial_data = 2;
  inline bool has_combat_initial_data() const;
  inline void clear_combat_initial_data();
  static const int kCombatInitialDataFieldNumber = 2;
  inline const ::tutorial::orcas::combat::protocol::CombatInitialData& combat_initial_data() const;
  inline ::tutorial::orcas::combat::protocol::CombatInitialData* mutable_combat_initial_data();
  inline ::tutorial::orcas::combat::protocol::CombatInitialData* release_combat_initial_data();
  inline void set_allocated_combat_initial_data(::tutorial::orcas::combat::protocol::CombatInitialData* combat_initial_data);

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.MessageCombatDeployRequest)
 private:
  inline void set_has_host_id();
  inline void clear_has_host_id();
  inline void set_has_combat_initial_data();
  inline void clear_has_combat_initial_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tutorial::orcas::combat::protocol::CombatInitialData* combat_initial_data_;
  ::google::protobuf::int32 host_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageCombatDeployRequest* default_instance_;
};
// -------------------------------------------------------------------

class MessageCombatDeployResponse : public ::google::protobuf::Message {
 public:
  MessageCombatDeployResponse();
  virtual ~MessageCombatDeployResponse();

  MessageCombatDeployResponse(const MessageCombatDeployResponse& from);

  inline MessageCombatDeployResponse& operator=(const MessageCombatDeployResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCombatDeployResponse& default_instance();

  void Swap(MessageCombatDeployResponse* other);

  // implements Message ----------------------------------------------

  MessageCombatDeployResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageCombatDeployResponse& from);
  void MergeFrom(const MessageCombatDeployResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 host_id = 1;
  inline bool has_host_id() const;
  inline void clear_host_id();
  static const int kHostIdFieldNumber = 1;
  inline ::google::protobuf::int32 host_id() const;
  inline void set_host_id(::google::protobuf::int32 value);

  // required int32 result_type = 2;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 2;
  inline ::google::protobuf::int32 result_type() const;
  inline void set_result_type(::google::protobuf::int32 value);

  // optional int32 combat_id = 3;
  inline bool has_combat_id() const;
  inline void clear_combat_id();
  static const int kCombatIdFieldNumber = 3;
  inline ::google::protobuf::int32 combat_id() const;
  inline void set_combat_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.MessageCombatDeployResponse)
 private:
  inline void set_has_host_id();
  inline void clear_has_host_id();
  inline void set_has_result_type();
  inline void clear_has_result_type();
  inline void set_has_combat_id();
  inline void clear_has_combat_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 host_id_;
  ::google::protobuf::int32 result_type_;
  ::google::protobuf::int32 combat_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageCombatDeployResponse* default_instance_;
};
// -------------------------------------------------------------------

class MessageCombatConnectArgentRequest : public ::google::protobuf::Message {
 public:
  MessageCombatConnectArgentRequest();
  virtual ~MessageCombatConnectArgentRequest();

  MessageCombatConnectArgentRequest(const MessageCombatConnectArgentRequest& from);

  inline MessageCombatConnectArgentRequest& operator=(const MessageCombatConnectArgentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCombatConnectArgentRequest& default_instance();

  void Swap(MessageCombatConnectArgentRequest* other);

  // implements Message ----------------------------------------------

  MessageCombatConnectArgentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageCombatConnectArgentRequest& from);
  void MergeFrom(const MessageCombatConnectArgentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 argent_id = 1;
  inline bool has_argent_id() const;
  inline void clear_argent_id();
  static const int kArgentIdFieldNumber = 1;
  inline ::google::protobuf::uint64 argent_id() const;
  inline void set_argent_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.MessageCombatConnectArgentRequest)
 private:
  inline void set_has_argent_id();
  inline void clear_has_argent_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 argent_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageCombatConnectArgentRequest* default_instance_;
};
// -------------------------------------------------------------------

class MessageCombatConnectArgentResponse : public ::google::protobuf::Message {
 public:
  MessageCombatConnectArgentResponse();
  virtual ~MessageCombatConnectArgentResponse();

  MessageCombatConnectArgentResponse(const MessageCombatConnectArgentResponse& from);

  inline MessageCombatConnectArgentResponse& operator=(const MessageCombatConnectArgentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCombatConnectArgentResponse& default_instance();

  void Swap(MessageCombatConnectArgentResponse* other);

  // implements Message ----------------------------------------------

  MessageCombatConnectArgentResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageCombatConnectArgentResponse& from);
  void MergeFrom(const MessageCombatConnectArgentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageCombatConnectArgentResponse_ErrorCode ErrorCode;
  static const ErrorCode ERROR_CODE_COMPLETE = MessageCombatConnectArgentResponse_ErrorCode_ERROR_CODE_COMPLETE;
  static const ErrorCode ERROR_CODE_FAILURE = MessageCombatConnectArgentResponse_ErrorCode_ERROR_CODE_FAILURE;
  static inline bool ErrorCode_IsValid(int value) {
    return MessageCombatConnectArgentResponse_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    MessageCombatConnectArgentResponse_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    MessageCombatConnectArgentResponse_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    MessageCombatConnectArgentResponse_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return MessageCombatConnectArgentResponse_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return MessageCombatConnectArgentResponse_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return MessageCombatConnectArgentResponse_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 ret_code = 1;
  inline bool has_ret_code() const;
  inline void clear_ret_code();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::int32 ret_code() const;
  inline void set_ret_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.MessageCombatConnectArgentResponse)
 private:
  inline void set_has_ret_code();
  inline void clear_has_ret_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageCombatConnectArgentResponse* default_instance_;
};
// -------------------------------------------------------------------

class MessageCombatArgentRequest : public ::google::protobuf::Message {
 public:
  MessageCombatArgentRequest();
  virtual ~MessageCombatArgentRequest();

  MessageCombatArgentRequest(const MessageCombatArgentRequest& from);

  inline MessageCombatArgentRequest& operator=(const MessageCombatArgentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCombatArgentRequest& default_instance();

  void Swap(MessageCombatArgentRequest* other);

  // implements Message ----------------------------------------------

  MessageCombatArgentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageCombatArgentRequest& from);
  void MergeFrom(const MessageCombatArgentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.MessageCombatArgentRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageCombatArgentRequest* default_instance_;
};
// -------------------------------------------------------------------

class MessageCombatArgentSync : public ::google::protobuf::Message {
 public:
  MessageCombatArgentSync();
  virtual ~MessageCombatArgentSync();

  MessageCombatArgentSync(const MessageCombatArgentSync& from);

  inline MessageCombatArgentSync& operator=(const MessageCombatArgentSync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageCombatArgentSync& default_instance();

  void Swap(MessageCombatArgentSync* other);

  // implements Message ----------------------------------------------

  MessageCombatArgentSync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageCombatArgentSync& from);
  void MergeFrom(const MessageCombatArgentSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:tutorial.orcas.combat.protocol.MessageCombatArgentSync)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static MessageCombatArgentSync* default_instance_;
};
// ===================================================================


// ===================================================================

// CombatRoleData

// required uint64 argent_id = 1;
inline bool CombatRoleData::has_argent_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CombatRoleData::set_has_argent_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CombatRoleData::clear_has_argent_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CombatRoleData::clear_argent_id() {
  argent_id_ = GOOGLE_ULONGLONG(0);
  clear_has_argent_id();
}
inline ::google::protobuf::uint64 CombatRoleData::argent_id() const {
  return argent_id_;
}
inline void CombatRoleData::set_argent_id(::google::protobuf::uint64 value) {
  set_has_argent_id();
  argent_id_ = value;
}

// required string ai = 2;
inline bool CombatRoleData::has_ai() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CombatRoleData::set_has_ai() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CombatRoleData::clear_has_ai() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CombatRoleData::clear_ai() {
  if (ai_ != &::google::protobuf::internal::kEmptyString) {
    ai_->clear();
  }
  clear_has_ai();
}
inline const ::std::string& CombatRoleData::ai() const {
  return *ai_;
}
inline void CombatRoleData::set_ai(const ::std::string& value) {
  set_has_ai();
  if (ai_ == &::google::protobuf::internal::kEmptyString) {
    ai_ = new ::std::string;
  }
  ai_->assign(value);
}
inline void CombatRoleData::set_ai(const char* value) {
  set_has_ai();
  if (ai_ == &::google::protobuf::internal::kEmptyString) {
    ai_ = new ::std::string;
  }
  ai_->assign(value);
}
inline void CombatRoleData::set_ai(const char* value, size_t size) {
  set_has_ai();
  if (ai_ == &::google::protobuf::internal::kEmptyString) {
    ai_ = new ::std::string;
  }
  ai_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CombatRoleData::mutable_ai() {
  set_has_ai();
  if (ai_ == &::google::protobuf::internal::kEmptyString) {
    ai_ = new ::std::string;
  }
  return ai_;
}
inline ::std::string* CombatRoleData::release_ai() {
  clear_has_ai();
  if (ai_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ai_;
    ai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CombatRoleData::set_allocated_ai(::std::string* ai) {
  if (ai_ != &::google::protobuf::internal::kEmptyString) {
    delete ai_;
  }
  if (ai) {
    set_has_ai();
    ai_ = ai;
  } else {
    clear_has_ai();
    ai_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .protocol.WarriorDescription warrior = 3;
inline int CombatRoleData::warrior_size() const {
  return warrior_.size();
}
inline void CombatRoleData::clear_warrior() {
  warrior_.Clear();
}
inline const ::protocol::WarriorDescription& CombatRoleData::warrior(int index) const {
  return warrior_.Get(index);
}
inline ::protocol::WarriorDescription* CombatRoleData::mutable_warrior(int index) {
  return warrior_.Mutable(index);
}
inline ::protocol::WarriorDescription* CombatRoleData::add_warrior() {
  return warrior_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::WarriorDescription >&
CombatRoleData::warrior() const {
  return warrior_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::WarriorDescription >*
CombatRoleData::mutable_warrior() {
  return &warrior_;
}

// -------------------------------------------------------------------

// CombatCampData

// required int32 id = 1;
inline bool CombatCampData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CombatCampData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CombatCampData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CombatCampData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CombatCampData::id() const {
  return id_;
}
inline void CombatCampData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .tutorial.orcas.combat.protocol.CombatRoleData role = 2;
inline int CombatCampData::role_size() const {
  return role_.size();
}
inline void CombatCampData::clear_role() {
  role_.Clear();
}
inline const ::tutorial::orcas::combat::protocol::CombatRoleData& CombatCampData::role(int index) const {
  return role_.Get(index);
}
inline ::tutorial::orcas::combat::protocol::CombatRoleData* CombatCampData::mutable_role(int index) {
  return role_.Mutable(index);
}
inline ::tutorial::orcas::combat::protocol::CombatRoleData* CombatCampData::add_role() {
  return role_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatRoleData >&
CombatCampData::role() const {
  return role_;
}
inline ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatRoleData >*
CombatCampData::mutable_role() {
  return &role_;
}

// -------------------------------------------------------------------

// CombatInitialData

// required int32 map_id = 1;
inline bool CombatInitialData::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CombatInitialData::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CombatInitialData::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CombatInitialData::clear_map_id() {
  map_id_ = 0;
  clear_has_map_id();
}
inline ::google::protobuf::int32 CombatInitialData::map_id() const {
  return map_id_;
}
inline void CombatInitialData::set_map_id(::google::protobuf::int32 value) {
  set_has_map_id();
  map_id_ = value;
}

// required int32 combat_type = 2;
inline bool CombatInitialData::has_combat_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CombatInitialData::set_has_combat_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CombatInitialData::clear_has_combat_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CombatInitialData::clear_combat_type() {
  combat_type_ = 0;
  clear_has_combat_type();
}
inline ::google::protobuf::int32 CombatInitialData::combat_type() const {
  return combat_type_;
}
inline void CombatInitialData::set_combat_type(::google::protobuf::int32 value) {
  set_has_combat_type();
  combat_type_ = value;
}

// repeated .tutorial.orcas.combat.protocol.CombatCampData camp = 3;
inline int CombatInitialData::camp_size() const {
  return camp_.size();
}
inline void CombatInitialData::clear_camp() {
  camp_.Clear();
}
inline const ::tutorial::orcas::combat::protocol::CombatCampData& CombatInitialData::camp(int index) const {
  return camp_.Get(index);
}
inline ::tutorial::orcas::combat::protocol::CombatCampData* CombatInitialData::mutable_camp(int index) {
  return camp_.Mutable(index);
}
inline ::tutorial::orcas::combat::protocol::CombatCampData* CombatInitialData::add_camp() {
  return camp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatCampData >&
CombatInitialData::camp() const {
  return camp_;
}
inline ::google::protobuf::RepeatedPtrField< ::tutorial::orcas::combat::protocol::CombatCampData >*
CombatInitialData::mutable_camp() {
  return &camp_;
}

// -------------------------------------------------------------------

// MessageCombatDeployRequest

// required int32 host_id = 1;
inline bool MessageCombatDeployRequest::has_host_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCombatDeployRequest::set_has_host_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCombatDeployRequest::clear_has_host_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCombatDeployRequest::clear_host_id() {
  host_id_ = 0;
  clear_has_host_id();
}
inline ::google::protobuf::int32 MessageCombatDeployRequest::host_id() const {
  return host_id_;
}
inline void MessageCombatDeployRequest::set_host_id(::google::protobuf::int32 value) {
  set_has_host_id();
  host_id_ = value;
}

// required .tutorial.orcas.combat.protocol.CombatInitialData combat_initial_data = 2;
inline bool MessageCombatDeployRequest::has_combat_initial_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageCombatDeployRequest::set_has_combat_initial_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageCombatDeployRequest::clear_has_combat_initial_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageCombatDeployRequest::clear_combat_initial_data() {
  if (combat_initial_data_ != NULL) combat_initial_data_->::tutorial::orcas::combat::protocol::CombatInitialData::Clear();
  clear_has_combat_initial_data();
}
inline const ::tutorial::orcas::combat::protocol::CombatInitialData& MessageCombatDeployRequest::combat_initial_data() const {
  return combat_initial_data_ != NULL ? *combat_initial_data_ : *default_instance_->combat_initial_data_;
}
inline ::tutorial::orcas::combat::protocol::CombatInitialData* MessageCombatDeployRequest::mutable_combat_initial_data() {
  set_has_combat_initial_data();
  if (combat_initial_data_ == NULL) combat_initial_data_ = new ::tutorial::orcas::combat::protocol::CombatInitialData;
  return combat_initial_data_;
}
inline ::tutorial::orcas::combat::protocol::CombatInitialData* MessageCombatDeployRequest::release_combat_initial_data() {
  clear_has_combat_initial_data();
  ::tutorial::orcas::combat::protocol::CombatInitialData* temp = combat_initial_data_;
  combat_initial_data_ = NULL;
  return temp;
}
inline void MessageCombatDeployRequest::set_allocated_combat_initial_data(::tutorial::orcas::combat::protocol::CombatInitialData* combat_initial_data) {
  delete combat_initial_data_;
  combat_initial_data_ = combat_initial_data;
  if (combat_initial_data) {
    set_has_combat_initial_data();
  } else {
    clear_has_combat_initial_data();
  }
}

// -------------------------------------------------------------------

// MessageCombatDeployResponse

// required int32 host_id = 1;
inline bool MessageCombatDeployResponse::has_host_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCombatDeployResponse::set_has_host_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCombatDeployResponse::clear_has_host_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCombatDeployResponse::clear_host_id() {
  host_id_ = 0;
  clear_has_host_id();
}
inline ::google::protobuf::int32 MessageCombatDeployResponse::host_id() const {
  return host_id_;
}
inline void MessageCombatDeployResponse::set_host_id(::google::protobuf::int32 value) {
  set_has_host_id();
  host_id_ = value;
}

// required int32 result_type = 2;
inline bool MessageCombatDeployResponse::has_result_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageCombatDeployResponse::set_has_result_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageCombatDeployResponse::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageCombatDeployResponse::clear_result_type() {
  result_type_ = 0;
  clear_has_result_type();
}
inline ::google::protobuf::int32 MessageCombatDeployResponse::result_type() const {
  return result_type_;
}
inline void MessageCombatDeployResponse::set_result_type(::google::protobuf::int32 value) {
  set_has_result_type();
  result_type_ = value;
}

// optional int32 combat_id = 3;
inline bool MessageCombatDeployResponse::has_combat_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageCombatDeployResponse::set_has_combat_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageCombatDeployResponse::clear_has_combat_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageCombatDeployResponse::clear_combat_id() {
  combat_id_ = 0;
  clear_has_combat_id();
}
inline ::google::protobuf::int32 MessageCombatDeployResponse::combat_id() const {
  return combat_id_;
}
inline void MessageCombatDeployResponse::set_combat_id(::google::protobuf::int32 value) {
  set_has_combat_id();
  combat_id_ = value;
}

// -------------------------------------------------------------------

// MessageCombatConnectArgentRequest

// required uint64 argent_id = 1;
inline bool MessageCombatConnectArgentRequest::has_argent_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCombatConnectArgentRequest::set_has_argent_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCombatConnectArgentRequest::clear_has_argent_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCombatConnectArgentRequest::clear_argent_id() {
  argent_id_ = GOOGLE_ULONGLONG(0);
  clear_has_argent_id();
}
inline ::google::protobuf::uint64 MessageCombatConnectArgentRequest::argent_id() const {
  return argent_id_;
}
inline void MessageCombatConnectArgentRequest::set_argent_id(::google::protobuf::uint64 value) {
  set_has_argent_id();
  argent_id_ = value;
}

// -------------------------------------------------------------------

// MessageCombatConnectArgentResponse

// required int32 ret_code = 1;
inline bool MessageCombatConnectArgentResponse::has_ret_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCombatConnectArgentResponse::set_has_ret_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCombatConnectArgentResponse::clear_has_ret_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCombatConnectArgentResponse::clear_ret_code() {
  ret_code_ = 0;
  clear_has_ret_code();
}
inline ::google::protobuf::int32 MessageCombatConnectArgentResponse::ret_code() const {
  return ret_code_;
}
inline void MessageCombatConnectArgentResponse::set_ret_code(::google::protobuf::int32 value) {
  set_has_ret_code();
  ret_code_ = value;
}

// -------------------------------------------------------------------

// MessageCombatArgentRequest

// required string type = 1;
inline bool MessageCombatArgentRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCombatArgentRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCombatArgentRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCombatArgentRequest::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& MessageCombatArgentRequest::type() const {
  return *type_;
}
inline void MessageCombatArgentRequest::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MessageCombatArgentRequest::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MessageCombatArgentRequest::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageCombatArgentRequest::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* MessageCombatArgentRequest::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageCombatArgentRequest::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes data = 2;
inline bool MessageCombatArgentRequest::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageCombatArgentRequest::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageCombatArgentRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageCombatArgentRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& MessageCombatArgentRequest::data() const {
  return *data_;
}
inline void MessageCombatArgentRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MessageCombatArgentRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MessageCombatArgentRequest::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageCombatArgentRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* MessageCombatArgentRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageCombatArgentRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageCombatArgentSync

// required string type = 1;
inline bool MessageCombatArgentSync::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageCombatArgentSync::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageCombatArgentSync::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageCombatArgentSync::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& MessageCombatArgentSync::type() const {
  return *type_;
}
inline void MessageCombatArgentSync::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MessageCombatArgentSync::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void MessageCombatArgentSync::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageCombatArgentSync::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* MessageCombatArgentSync::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageCombatArgentSync::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes data = 2;
inline bool MessageCombatArgentSync::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageCombatArgentSync::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageCombatArgentSync::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageCombatArgentSync::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& MessageCombatArgentSync::data() const {
  return *data_;
}
inline void MessageCombatArgentSync::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MessageCombatArgentSync::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void MessageCombatArgentSync::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageCombatArgentSync::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* MessageCombatArgentSync::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageCombatArgentSync::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace combat
}  // namespace orcas
}  // namespace tutorial

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::orcas::combat::protocol::MessageCombatConnectArgentResponse_ErrorCode>() {
  return ::tutorial::orcas::combat::protocol::MessageCombatConnectArgentResponse_ErrorCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::orcas::combat::protocol::CombatType>() {
  return ::tutorial::orcas::combat::protocol::CombatType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::orcas::combat::protocol::CombatDeployResultType>() {
  return ::tutorial::orcas::combat::protocol::CombatDeployResultType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
